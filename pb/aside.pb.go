// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: aside.proto

package aside

import (
	fmt "fmt"
	github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Define the api to use, expect more in the future.
type Proto int32

const (
	// Used to transmit error.
	Proto_NO_PROTO             Proto = 0
	Proto_NO_PROTO_TRICKLE     Proto = 1
	Proto_DATA_CHANNEL         Proto = 2
	Proto_DATA_CHANNEL_TRICKLE Proto = 3
	Proto_SCTP                 Proto = 4
	Proto_SCTP_TRICKLE         Proto = 5
	Proto_ORTC                 Proto = 6
	Proto_ORTC_TRICKLE         Proto = 7
)

var Proto_name = map[int32]string{
	0: "NO_PROTO",
	1: "NO_PROTO_TRICKLE",
	2: "DATA_CHANNEL",
	3: "DATA_CHANNEL_TRICKLE",
	4: "SCTP",
	5: "SCTP_TRICKLE",
	6: "ORTC",
	7: "ORTC_TRICKLE",
}

var Proto_value = map[string]int32{
	"NO_PROTO":             0,
	"NO_PROTO_TRICKLE":     1,
	"DATA_CHANNEL":         2,
	"DATA_CHANNEL_TRICKLE": 3,
	"SCTP":                 4,
	"SCTP_TRICKLE":         5,
	"ORTC":                 6,
	"ORTC_TRICKLE":         7,
}

func (x Proto) Enum() *Proto {
	p := new(Proto)
	*p = x
	return p
}

func (x Proto) String() string {
	return proto.EnumName(Proto_name, int32(x))
}

func (x *Proto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Proto_value, data, "Proto")
	if err != nil {
		return err
	}
	*x = Proto(value)
	return nil
}

func (Proto) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{0}
}

type Terminate_Reason int32

const (
	Terminate_SUCCESS             Terminate_Reason = 100
	Terminate_RAN_OUT_STUN_SERVER Terminate_Reason = 201
	Terminate_RAN_OUT_OF_RETRIES  Terminate_Reason = 202
	Terminate_PRIVATE_IP_STUN     Terminate_Reason = 203
	Terminate_MALFORMED_MESSAGE   Terminate_Reason = 400
	Terminate_UNKOWN_ERROR        Terminate_Reason = 401
)

var Terminate_Reason_name = map[int32]string{
	100: "SUCCESS",
	201: "RAN_OUT_STUN_SERVER",
	202: "RAN_OUT_OF_RETRIES",
	203: "PRIVATE_IP_STUN",
	400: "MALFORMED_MESSAGE",
	401: "UNKOWN_ERROR",
}

var Terminate_Reason_value = map[string]int32{
	"SUCCESS":             100,
	"RAN_OUT_STUN_SERVER": 201,
	"RAN_OUT_OF_RETRIES":  202,
	"PRIVATE_IP_STUN":     203,
	"MALFORMED_MESSAGE":   400,
	"UNKOWN_ERROR":        401,
}

func (x Terminate_Reason) Enum() *Terminate_Reason {
	p := new(Terminate_Reason)
	*p = x
	return p
}

func (x Terminate_Reason) String() string {
	return proto.EnumName(Terminate_Reason_name, int32(x))
}

func (x *Terminate_Reason) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Terminate_Reason_value, data, "Terminate_Reason")
	if err != nil {
		return err
	}
	*x = Terminate_Reason(value)
	return nil
}

func (Terminate_Reason) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{7, 0}
}

type Hello struct {
	Protos        []Proto `protobuf:"varint,1,rep,name=protos,enum=aside.Proto" json:"protos,omitempty"`
	ShareStun     *bool   `protobuf:"varint,2,req,name=shareStun" json:"shareStun,omitempty"`
	ShareGoodStun *bool   `protobuf:"varint,3,req,name=shareGoodStun" json:"shareGoodStun,omitempty"`
	NeedStun      *bool   `protobuf:"varint,4,req,name=needStun" json:"needStun,omitempty"`
	// Want stun explicitely ask for unkown status STUN.
	WantStun *bool `protobuf:"varint,5,req,name=wantStun" json:"wantStun,omitempty"`
	// Want good stun explicitely ask for good known STUN.
	WantGoodStun         *bool    `protobuf:"varint,6,req,name=wantGoodStun" json:"wantGoodStun,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Hello) Reset()         { *m = Hello{} }
func (m *Hello) String() string { return proto.CompactTextString(m) }
func (*Hello) ProtoMessage()    {}
func (*Hello) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{0}
}
func (m *Hello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Hello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Hello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Hello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Hello.Merge(m, src)
}
func (m *Hello) XXX_Size() int {
	return m.Size()
}
func (m *Hello) XXX_DiscardUnknown() {
	xxx_messageInfo_Hello.DiscardUnknown(m)
}

var xxx_messageInfo_Hello proto.InternalMessageInfo

func (m *Hello) GetProtos() []Proto {
	if m != nil {
		return m.Protos
	}
	return nil
}

func (m *Hello) GetShareStun() bool {
	if m != nil && m.ShareStun != nil {
		return *m.ShareStun
	}
	return false
}

func (m *Hello) GetShareGoodStun() bool {
	if m != nil && m.ShareGoodStun != nil {
		return *m.ShareGoodStun
	}
	return false
}

func (m *Hello) GetNeedStun() bool {
	if m != nil && m.NeedStun != nil {
		return *m.NeedStun
	}
	return false
}

func (m *Hello) GetWantStun() bool {
	if m != nil && m.WantStun != nil {
		return *m.WantStun
	}
	return false
}

func (m *Hello) GetWantGoodStun() bool {
	if m != nil && m.WantGoodStun != nil {
		return *m.WantGoodStun
	}
	return false
}

// Stun Server is a message used to be nested as list.
type StunServer struct {
	// Without `stun:`
	Domain               *string  `protobuf:"bytes,1,req,name=domain" json:"domain,omitempty"`
	Port                 *uint32  `protobuf:"varint,2,req,name=port" json:"port,omitempty"`
	KnownGood            *bool    `protobuf:"varint,3,req,name=knownGood" json:"knownGood,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StunServer) Reset()         { *m = StunServer{} }
func (m *StunServer) String() string { return proto.CompactTextString(m) }
func (*StunServer) ProtoMessage()    {}
func (*StunServer) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{1}
}
func (m *StunServer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StunServer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StunServer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StunServer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StunServer.Merge(m, src)
}
func (m *StunServer) XXX_Size() int {
	return m.Size()
}
func (m *StunServer) XXX_DiscardUnknown() {
	xxx_messageInfo_StunServer.DiscardUnknown(m)
}

var xxx_messageInfo_StunServer proto.InternalMessageInfo

func (m *StunServer) GetDomain() string {
	if m != nil && m.Domain != nil {
		return *m.Domain
	}
	return ""
}

func (m *StunServer) GetPort() uint32 {
	if m != nil && m.Port != nil {
		return *m.Port
	}
	return 0
}

func (m *StunServer) GetKnownGood() bool {
	if m != nil && m.KnownGood != nil {
		return *m.KnownGood
	}
	return false
}

type StunShare struct {
	StunServers          []*StunServer `protobuf:"bytes,1,rep,name=stunServers" json:"stunServers,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *StunShare) Reset()         { *m = StunShare{} }
func (m *StunShare) String() string { return proto.CompactTextString(m) }
func (*StunShare) ProtoMessage()    {}
func (*StunShare) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{2}
}
func (m *StunShare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StunShare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StunShare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StunShare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StunShare.Merge(m, src)
}
func (m *StunShare) XXX_Size() int {
	return m.Size()
}
func (m *StunShare) XXX_DiscardUnknown() {
	xxx_messageInfo_StunShare.DiscardUnknown(m)
}

var xxx_messageInfo_StunShare proto.InternalMessageInfo

func (m *StunShare) GetStunServers() []*StunServer {
	if m != nil {
		return m.StunServers
	}
	return nil
}

// SDP exchange, assume offer if sended by the initiator and reverse.
type SDP struct {
	Sdp                  *string  `protobuf:"bytes,1,req,name=sdp" json:"sdp,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SDP) Reset()         { *m = SDP{} }
func (m *SDP) String() string { return proto.CompactTextString(m) }
func (*SDP) ProtoMessage()    {}
func (*SDP) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{3}
}
func (m *SDP) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SDP) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SDP.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SDP) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SDP.Merge(m, src)
}
func (m *SDP) XXX_Size() int {
	return m.Size()
}
func (m *SDP) XXX_DiscardUnknown() {
	xxx_messageInfo_SDP.DiscardUnknown(m)
}

var xxx_messageInfo_SDP proto.InternalMessageInfo

func (m *SDP) GetSdp() string {
	if m != nil && m.Sdp != nil {
		return *m.Sdp
	}
	return ""
}

type GenerationEnded struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *GenerationEnded) Reset()         { *m = GenerationEnded{} }
func (m *GenerationEnded) String() string { return proto.CompactTextString(m) }
func (*GenerationEnded) ProtoMessage()    {}
func (*GenerationEnded) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{4}
}
func (m *GenerationEnded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GenerationEnded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GenerationEnded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GenerationEnded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenerationEnded.Merge(m, src)
}
func (m *GenerationEnded) XXX_Size() int {
	return m.Size()
}
func (m *GenerationEnded) XXX_DiscardUnknown() {
	xxx_messageInfo_GenerationEnded.DiscardUnknown(m)
}

var xxx_messageInfo_GenerationEnded proto.InternalMessageInfo

type AnswerTestingEnded struct {
	MoreStun             *bool    `protobuf:"varint,1,req,name=moreStun" json:"moreStun,omitempty"`
	MoreGoodStun         *bool    `protobuf:"varint,2,req,name=moreGoodStun" json:"moreGoodStun,omitempty"`
	Retry                *bool    `protobuf:"varint,3,req,name=retry" json:"retry,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AnswerTestingEnded) Reset()         { *m = AnswerTestingEnded{} }
func (m *AnswerTestingEnded) String() string { return proto.CompactTextString(m) }
func (*AnswerTestingEnded) ProtoMessage()    {}
func (*AnswerTestingEnded) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{5}
}
func (m *AnswerTestingEnded) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AnswerTestingEnded) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AnswerTestingEnded.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AnswerTestingEnded) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AnswerTestingEnded.Merge(m, src)
}
func (m *AnswerTestingEnded) XXX_Size() int {
	return m.Size()
}
func (m *AnswerTestingEnded) XXX_DiscardUnknown() {
	xxx_messageInfo_AnswerTestingEnded.DiscardUnknown(m)
}

var xxx_messageInfo_AnswerTestingEnded proto.InternalMessageInfo

func (m *AnswerTestingEnded) GetMoreStun() bool {
	if m != nil && m.MoreStun != nil {
		return *m.MoreStun
	}
	return false
}

func (m *AnswerTestingEnded) GetMoreGoodStun() bool {
	if m != nil && m.MoreGoodStun != nil {
		return *m.MoreGoodStun
	}
	return false
}

func (m *AnswerTestingEnded) GetRetry() bool {
	if m != nil && m.Retry != nil {
		return *m.Retry
	}
	return false
}

type AcceptRetry struct {
	MoreStun             *bool    `protobuf:"varint,1,req,name=moreStun" json:"moreStun,omitempty"`
	MoreGoodStun         *bool    `protobuf:"varint,2,req,name=moreGoodStun" json:"moreGoodStun,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AcceptRetry) Reset()         { *m = AcceptRetry{} }
func (m *AcceptRetry) String() string { return proto.CompactTextString(m) }
func (*AcceptRetry) ProtoMessage()    {}
func (*AcceptRetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{6}
}
func (m *AcceptRetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AcceptRetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AcceptRetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AcceptRetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AcceptRetry.Merge(m, src)
}
func (m *AcceptRetry) XXX_Size() int {
	return m.Size()
}
func (m *AcceptRetry) XXX_DiscardUnknown() {
	xxx_messageInfo_AcceptRetry.DiscardUnknown(m)
}

var xxx_messageInfo_AcceptRetry proto.InternalMessageInfo

func (m *AcceptRetry) GetMoreStun() bool {
	if m != nil && m.MoreStun != nil {
		return *m.MoreStun
	}
	return false
}

func (m *AcceptRetry) GetMoreGoodStun() bool {
	if m != nil && m.MoreGoodStun != nil {
		return *m.MoreGoodStun
	}
	return false
}

// Except if closing with SUCCESS an implementation may terminate violently (not sending Terminate message).
type Terminate struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Terminate) Reset()         { *m = Terminate{} }
func (m *Terminate) String() string { return proto.CompactTextString(m) }
func (*Terminate) ProtoMessage()    {}
func (*Terminate) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{7}
}
func (m *Terminate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Terminate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Terminate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Terminate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Terminate.Merge(m, src)
}
func (m *Terminate) XXX_Size() int {
	return m.Size()
}
func (m *Terminate) XXX_DiscardUnknown() {
	xxx_messageInfo_Terminate.DiscardUnknown(m)
}

var xxx_messageInfo_Terminate proto.InternalMessageInfo

type WrapExchange struct {
	// Types that are valid to be assigned to M:
	//	*WrapExchange_Terminate
	//	*WrapExchange_Sdp
	//	*WrapExchange_Genend
	M                    isWrapExchange_M `protobuf_oneof:"m"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *WrapExchange) Reset()         { *m = WrapExchange{} }
func (m *WrapExchange) String() string { return proto.CompactTextString(m) }
func (*WrapExchange) ProtoMessage()    {}
func (*WrapExchange) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{8}
}
func (m *WrapExchange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapExchange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapExchange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapExchange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapExchange.Merge(m, src)
}
func (m *WrapExchange) XXX_Size() int {
	return m.Size()
}
func (m *WrapExchange) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapExchange.DiscardUnknown(m)
}

var xxx_messageInfo_WrapExchange proto.InternalMessageInfo

type isWrapExchange_M interface {
	isWrapExchange_M()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WrapExchange_Terminate struct {
	Terminate *Terminate `protobuf:"bytes,1,opt,name=terminate,oneof" json:"terminate,omitempty"`
}
type WrapExchange_Sdp struct {
	Sdp *SDP `protobuf:"bytes,2,opt,name=sdp,oneof" json:"sdp,omitempty"`
}
type WrapExchange_Genend struct {
	Genend *GenerationEnded `protobuf:"bytes,3,opt,name=genend,oneof" json:"genend,omitempty"`
}

func (*WrapExchange_Terminate) isWrapExchange_M() {}
func (*WrapExchange_Sdp) isWrapExchange_M()       {}
func (*WrapExchange_Genend) isWrapExchange_M()    {}

func (m *WrapExchange) GetM() isWrapExchange_M {
	if m != nil {
		return m.M
	}
	return nil
}

func (m *WrapExchange) GetTerminate() *Terminate {
	if x, ok := m.GetM().(*WrapExchange_Terminate); ok {
		return x.Terminate
	}
	return nil
}

func (m *WrapExchange) GetSdp() *SDP {
	if x, ok := m.GetM().(*WrapExchange_Sdp); ok {
		return x.Sdp
	}
	return nil
}

func (m *WrapExchange) GetGenend() *GenerationEnded {
	if x, ok := m.GetM().(*WrapExchange_Genend); ok {
		return x.Genend
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WrapExchange) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WrapExchange_Terminate)(nil),
		(*WrapExchange_Sdp)(nil),
		(*WrapExchange_Genend)(nil),
	}
}

type WrapAnswerEnd struct {
	// Types that are valid to be assigned to M:
	//	*WrapAnswerEnd_Terminate
	//	*WrapAnswerEnd_Answerend
	M                    isWrapAnswerEnd_M `protobuf_oneof:"m"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *WrapAnswerEnd) Reset()         { *m = WrapAnswerEnd{} }
func (m *WrapAnswerEnd) String() string { return proto.CompactTextString(m) }
func (*WrapAnswerEnd) ProtoMessage()    {}
func (*WrapAnswerEnd) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{9}
}
func (m *WrapAnswerEnd) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapAnswerEnd) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapAnswerEnd.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapAnswerEnd) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapAnswerEnd.Merge(m, src)
}
func (m *WrapAnswerEnd) XXX_Size() int {
	return m.Size()
}
func (m *WrapAnswerEnd) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapAnswerEnd.DiscardUnknown(m)
}

var xxx_messageInfo_WrapAnswerEnd proto.InternalMessageInfo

type isWrapAnswerEnd_M interface {
	isWrapAnswerEnd_M()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WrapAnswerEnd_Terminate struct {
	Terminate *Terminate `protobuf:"bytes,1,opt,name=terminate,oneof" json:"terminate,omitempty"`
}
type WrapAnswerEnd_Answerend struct {
	Answerend *AnswerTestingEnded `protobuf:"bytes,2,opt,name=answerend,oneof" json:"answerend,omitempty"`
}

func (*WrapAnswerEnd_Terminate) isWrapAnswerEnd_M() {}
func (*WrapAnswerEnd_Answerend) isWrapAnswerEnd_M() {}

func (m *WrapAnswerEnd) GetM() isWrapAnswerEnd_M {
	if m != nil {
		return m.M
	}
	return nil
}

func (m *WrapAnswerEnd) GetTerminate() *Terminate {
	if x, ok := m.GetM().(*WrapAnswerEnd_Terminate); ok {
		return x.Terminate
	}
	return nil
}

func (m *WrapAnswerEnd) GetAnswerend() *AnswerTestingEnded {
	if x, ok := m.GetM().(*WrapAnswerEnd_Answerend); ok {
		return x.Answerend
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WrapAnswerEnd) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WrapAnswerEnd_Terminate)(nil),
		(*WrapAnswerEnd_Answerend)(nil),
	}
}

type WrapRetryAccept struct {
	// Types that are valid to be assigned to M:
	//	*WrapRetryAccept_Terminate
	//	*WrapRetryAccept_Retry
	M                    isWrapRetryAccept_M `protobuf_oneof:"m"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *WrapRetryAccept) Reset()         { *m = WrapRetryAccept{} }
func (m *WrapRetryAccept) String() string { return proto.CompactTextString(m) }
func (*WrapRetryAccept) ProtoMessage()    {}
func (*WrapRetryAccept) Descriptor() ([]byte, []int) {
	return fileDescriptor_6c94e6a4a939e96f, []int{10}
}
func (m *WrapRetryAccept) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WrapRetryAccept) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WrapRetryAccept.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WrapRetryAccept) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WrapRetryAccept.Merge(m, src)
}
func (m *WrapRetryAccept) XXX_Size() int {
	return m.Size()
}
func (m *WrapRetryAccept) XXX_DiscardUnknown() {
	xxx_messageInfo_WrapRetryAccept.DiscardUnknown(m)
}

var xxx_messageInfo_WrapRetryAccept proto.InternalMessageInfo

type isWrapRetryAccept_M interface {
	isWrapRetryAccept_M()
	MarshalTo([]byte) (int, error)
	Size() int
}

type WrapRetryAccept_Terminate struct {
	Terminate *Terminate `protobuf:"bytes,1,opt,name=terminate,oneof" json:"terminate,omitempty"`
}
type WrapRetryAccept_Retry struct {
	Retry *AcceptRetry `protobuf:"bytes,2,opt,name=retry,oneof" json:"retry,omitempty"`
}

func (*WrapRetryAccept_Terminate) isWrapRetryAccept_M() {}
func (*WrapRetryAccept_Retry) isWrapRetryAccept_M()     {}

func (m *WrapRetryAccept) GetM() isWrapRetryAccept_M {
	if m != nil {
		return m.M
	}
	return nil
}

func (m *WrapRetryAccept) GetTerminate() *Terminate {
	if x, ok := m.GetM().(*WrapRetryAccept_Terminate); ok {
		return x.Terminate
	}
	return nil
}

func (m *WrapRetryAccept) GetRetry() *AcceptRetry {
	if x, ok := m.GetM().(*WrapRetryAccept_Retry); ok {
		return x.Retry
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*WrapRetryAccept) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*WrapRetryAccept_Terminate)(nil),
		(*WrapRetryAccept_Retry)(nil),
	}
}

func init() {
	proto.RegisterEnum("aside.Proto", Proto_name, Proto_value)
	proto.RegisterEnum("aside.Terminate_Reason", Terminate_Reason_name, Terminate_Reason_value)
	proto.RegisterType((*Hello)(nil), "aside.Hello")
	proto.RegisterType((*StunServer)(nil), "aside.StunServer")
	proto.RegisterType((*StunShare)(nil), "aside.StunShare")
	proto.RegisterType((*SDP)(nil), "aside.SDP")
	proto.RegisterType((*GenerationEnded)(nil), "aside.GenerationEnded")
	proto.RegisterType((*AnswerTestingEnded)(nil), "aside.AnswerTestingEnded")
	proto.RegisterType((*AcceptRetry)(nil), "aside.AcceptRetry")
	proto.RegisterType((*Terminate)(nil), "aside.Terminate")
	proto.RegisterType((*WrapExchange)(nil), "aside.WrapExchange")
	proto.RegisterType((*WrapAnswerEnd)(nil), "aside.WrapAnswerEnd")
	proto.RegisterType((*WrapRetryAccept)(nil), "aside.WrapRetryAccept")
}

func init() { proto.RegisterFile("aside.proto", fileDescriptor_6c94e6a4a939e96f) }

var fileDescriptor_6c94e6a4a939e96f = []byte{
	// 685 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0xd6, 0x8a, 0x92, 0x2c, 0x8d, 0xe4, 0x7a, 0x35, 0x15, 0x6c, 0xb5, 0x28, 0x04, 0x81, 0xf0,
	0x41, 0xf0, 0xc1, 0x30, 0xdc, 0x53, 0x6f, 0xa5, 0xa5, 0xb5, 0x25, 0xd8, 0x12, 0x85, 0x25, 0x65,
	0x1f, 0x09, 0xc2, 0x5c, 0xd8, 0x6a, 0xad, 0xa5, 0x40, 0xb2, 0x75, 0x7b, 0xcc, 0x31, 0xa7, 0x24,
	0xa7, 0xbc, 0x52, 0x7e, 0x10, 0x20, 0x8f, 0x10, 0xf8, 0x49, 0x82, 0x5d, 0xfe, 0xc8, 0x4e, 0x6e,
	0xce, 0x89, 0x33, 0xf3, 0x7d, 0xb3, 0xf3, 0xcd, 0x0f, 0x08, 0x4d, 0x3f, 0x5e, 0x06, 0xe2, 0x70,
	0x1d, 0x85, 0x49, 0x88, 0x55, 0xed, 0x98, 0x9f, 0x08, 0x54, 0xc7, 0xe2, 0xee, 0x2e, 0xc4, 0x7d,
	0xa8, 0x69, 0x24, 0xee, 0x92, 0xbe, 0x31, 0xf8, 0xe9, 0xb8, 0x75, 0x98, 0xd2, 0xe7, 0x2a, 0xc8,
	0x33, 0x0c, 0x7f, 0x83, 0x46, 0x7c, 0xeb, 0x47, 0xc2, 0x49, 0xfe, 0x91, 0xdd, 0x72, 0xbf, 0x3c,
	0xa8, 0xf3, 0x4d, 0x00, 0xf7, 0x61, 0x5b, 0x3b, 0x67, 0x61, 0x18, 0x68, 0x86, 0xa1, 0x19, 0x4f,
	0x83, 0xf8, 0x2b, 0xd4, 0xa5, 0x10, 0x29, 0xa1, 0xa2, 0x09, 0x85, 0xaf, 0xb0, 0x7b, 0x5f, 0x26,
	0x1a, 0xab, 0xa6, 0x58, 0xee, 0xa3, 0x09, 0x2d, 0x65, 0x17, 0x8f, 0xd7, 0x34, 0xfe, 0x24, 0x66,
	0x5e, 0x02, 0xa8, 0xaf, 0x23, 0xa2, 0x7f, 0x45, 0x84, 0xbb, 0x50, 0x0b, 0xc2, 0x95, 0xbf, 0x94,
	0x5d, 0xd2, 0x2f, 0x0f, 0x1a, 0x3c, 0xf3, 0x10, 0xa1, 0xb2, 0x0e, 0xa3, 0x44, 0x37, 0xb0, 0xcd,
	0xb5, 0xad, 0x3a, 0xfb, 0x5b, 0x86, 0xf7, 0x52, 0x3d, 0x95, 0xe9, 0xde, 0x04, 0xcc, 0x3f, 0xa1,
	0xa1, 0xdf, 0x55, 0x8d, 0xe0, 0xef, 0xd0, 0x8c, 0x8b, 0x22, 0xe9, 0xbc, 0x9a, 0xc7, 0xed, 0x6c,
	0x5e, 0x9b, 0xf2, 0xfc, 0x31, 0xcb, 0xdc, 0x03, 0xc3, 0x19, 0xcd, 0x91, 0x82, 0x11, 0x07, 0xeb,
	0x4c, 0x8f, 0x32, 0xcd, 0x36, 0xec, 0x9c, 0x09, 0x29, 0x22, 0x3f, 0x59, 0x86, 0x92, 0xc9, 0x40,
	0x04, 0xe6, 0x5f, 0x80, 0x96, 0x8c, 0xef, 0x45, 0xe4, 0x8a, 0x38, 0x59, 0xca, 0x1b, 0x1d, 0x55,
	0xb3, 0x59, 0x85, 0xd9, 0xe8, 0x49, 0x3a, 0x9b, 0xdc, 0x57, 0xb3, 0x51, 0x76, 0x31, 0x9b, 0x74,
	0x35, 0x4f, 0x62, 0xd8, 0x81, 0x6a, 0x24, 0x92, 0xe8, 0xff, 0xac, 0xbb, 0xd4, 0x31, 0xa7, 0xd0,
	0xb4, 0xae, 0xaf, 0xc5, 0x3a, 0xe1, 0xca, 0xfd, 0xd1, 0x22, 0xe6, 0x5b, 0x02, 0x0d, 0x57, 0x44,
	0xab, 0xa5, 0xf4, 0x13, 0x61, 0xbe, 0x24, 0x50, 0xe3, 0xc2, 0x8f, 0x43, 0x89, 0x4d, 0xd8, 0x72,
	0x16, 0xc3, 0x21, 0x73, 0x1c, 0x1a, 0x60, 0x17, 0x7e, 0xe6, 0xd6, 0xcc, 0xb3, 0x17, 0xae, 0xe7,
	0xb8, 0x8b, 0x99, 0xe7, 0x30, 0x7e, 0xc9, 0x38, 0x7d, 0x4f, 0x70, 0x0f, 0x30, 0x47, 0xec, 0x53,
	0x8f, 0x33, 0x97, 0x4f, 0x98, 0x43, 0x3f, 0x10, 0xec, 0xc0, 0xce, 0x9c, 0x4f, 0x2e, 0x2d, 0x97,
	0x79, 0x93, 0xb9, 0xce, 0xa2, 0x1f, 0x09, 0xee, 0x42, 0x7b, 0x6a, 0x5d, 0x9c, 0xda, 0x7c, 0xca,
	0x46, 0xde, 0x94, 0x39, 0x8e, 0x75, 0xc6, 0xe8, 0x6b, 0x03, 0xdb, 0xd0, 0x5a, 0xcc, 0xce, 0xed,
	0xab, 0x99, 0xc7, 0x38, 0xb7, 0x39, 0x7d, 0x63, 0x28, 0x65, 0xad, 0xab, 0xc8, 0x5f, 0xb3, 0xff,
	0xae, 0x6f, 0x7d, 0x79, 0x23, 0xf0, 0x08, 0x1a, 0x49, 0xae, 0xb4, 0x4b, 0xfa, 0x64, 0xd0, 0x3c,
	0xa6, 0xd9, 0x12, 0x8b, 0x0e, 0xc6, 0x25, 0xbe, 0x21, 0x61, 0x2f, 0x5d, 0x5e, 0x59, 0x73, 0x21,
	0x5f, 0xf8, 0x68, 0x3e, 0x2e, 0xe9, 0x55, 0xe2, 0x11, 0xd4, 0x6e, 0x84, 0x14, 0x52, 0x1d, 0x90,
	0xa2, 0xec, 0x66, 0x94, 0x6f, 0xf6, 0x3b, 0x2e, 0xf1, 0x8c, 0x77, 0x62, 0x00, 0x59, 0x99, 0x2f,
	0x08, 0x6c, 0x2b, 0x65, 0xe9, 0xce, 0x99, 0x0c, 0x9e, 0x21, 0xed, 0x0f, 0x68, 0xf8, 0x3a, 0x5d,
	0x55, 0x4f, 0x05, 0xfe, 0x92, 0x65, 0x7c, 0x7f, 0x4a, 0x2a, 0xb5, 0x60, 0xa7, 0x1a, 0x12, 0xd8,
	0x51, 0x12, 0xf4, 0x11, 0xa4, 0xf7, 0xf0, 0x0c, 0x11, 0x07, 0xf9, 0x85, 0xa5, 0x02, 0x30, 0x17,
	0xb0, 0xb9, 0xaf, 0x71, 0x29, 0xbb, 0x3b, 0x5d, 0xf5, 0xe0, 0x15, 0x81, 0xaa, 0xfe, 0xc1, 0x60,
	0x0b, 0xea, 0x33, 0xdb, 0x9b, 0x73, 0xdb, 0xb5, 0x69, 0x09, 0x3b, 0x40, 0x73, 0xcf, 0x73, 0xf9,
	0x64, 0x78, 0x7e, 0xc1, 0x28, 0x41, 0x0a, 0xad, 0x91, 0xe5, 0x5a, 0xde, 0x70, 0x6c, 0xcd, 0x66,
	0xec, 0x82, 0x96, 0xb1, 0x0b, 0x9d, 0xc7, 0x91, 0x82, 0x6b, 0x60, 0x1d, 0x2a, 0xce, 0xd0, 0x9d,
	0xd3, 0x8a, 0xca, 0x52, 0x56, 0x81, 0x55, 0x15, 0x66, 0x73, 0x77, 0x48, 0x6b, 0x0a, 0x53, 0x56,
	0x81, 0x6d, 0x9d, 0xb4, 0xde, 0x3d, 0xf4, 0xc8, 0xe7, 0x87, 0x1e, 0xf9, 0xf2, 0xd0, 0x23, 0x5f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0x30, 0x7d, 0xd8, 0x01, 0x33, 0x05, 0x00, 0x00,
}

func (m *Hello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Hello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Hello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.WantGoodStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("wantGoodStun")
	} else {
		i--
		if *m.WantGoodStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.WantStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("wantStun")
	} else {
		i--
		if *m.WantStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.NeedStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("needStun")
	} else {
		i--
		if *m.NeedStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.ShareGoodStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("shareGoodStun")
	} else {
		i--
		if *m.ShareGoodStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.ShareStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("shareStun")
	} else {
		i--
		if *m.ShareStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.Protos) > 0 {
		for iNdEx := len(m.Protos) - 1; iNdEx >= 0; iNdEx-- {
			i = encodeVarintAside(dAtA, i, uint64(m.Protos[iNdEx]))
			i--
			dAtA[i] = 0x8
		}
	}
	return len(dAtA) - i, nil
}

func (m *StunServer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StunServer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StunServer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.KnownGood == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("knownGood")
	} else {
		i--
		if *m.KnownGood {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Port == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	} else {
		i = encodeVarintAside(dAtA, i, uint64(*m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Domain == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("domain")
	} else {
		i -= len(*m.Domain)
		copy(dAtA[i:], *m.Domain)
		i = encodeVarintAside(dAtA, i, uint64(len(*m.Domain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *StunShare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StunShare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StunShare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.StunServers) > 0 {
		for iNdEx := len(m.StunServers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StunServers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintAside(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SDP) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SDP) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SDP) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sdp == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("sdp")
	} else {
		i -= len(*m.Sdp)
		copy(dAtA[i:], *m.Sdp)
		i = encodeVarintAside(dAtA, i, uint64(len(*m.Sdp)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GenerationEnded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GenerationEnded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GenerationEnded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *AnswerTestingEnded) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AnswerTestingEnded) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AnswerTestingEnded) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Retry == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("retry")
	} else {
		i--
		if *m.Retry {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.MoreGoodStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreGoodStun")
	} else {
		i--
		if *m.MoreGoodStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MoreStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreStun")
	} else {
		i--
		if *m.MoreStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AcceptRetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AcceptRetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AcceptRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.MoreGoodStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreGoodStun")
	} else {
		i--
		if *m.MoreGoodStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.MoreStun == nil {
		return 0, github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreStun")
	} else {
		i--
		if *m.MoreStun {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Terminate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Terminate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Terminate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *WrapExchange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapExchange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapExchange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.M != nil {
		{
			size := m.M.Size()
			i -= size
			if _, err := m.M.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WrapExchange_Terminate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapExchange_Terminate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Terminate != nil {
		{
			size, err := m.Terminate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WrapExchange_Sdp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapExchange_Sdp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sdp != nil {
		{
			size, err := m.Sdp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WrapExchange_Genend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapExchange_Genend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Genend != nil {
		{
			size, err := m.Genend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *WrapAnswerEnd) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapAnswerEnd) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapAnswerEnd) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.M != nil {
		{
			size := m.M.Size()
			i -= size
			if _, err := m.M.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WrapAnswerEnd_Terminate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapAnswerEnd_Terminate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Terminate != nil {
		{
			size, err := m.Terminate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WrapAnswerEnd_Answerend) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapAnswerEnd_Answerend) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Answerend != nil {
		{
			size, err := m.Answerend.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *WrapRetryAccept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WrapRetryAccept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapRetryAccept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.M != nil {
		{
			size := m.M.Size()
			i -= size
			if _, err := m.M.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *WrapRetryAccept_Terminate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapRetryAccept_Terminate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Terminate != nil {
		{
			size, err := m.Terminate.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *WrapRetryAccept_Retry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WrapRetryAccept_Retry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Retry != nil {
		{
			size, err := m.Retry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAside(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func encodeVarintAside(dAtA []byte, offset int, v uint64) int {
	offset -= sovAside(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Hello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Protos) > 0 {
		for _, e := range m.Protos {
			n += 1 + sovAside(uint64(e))
		}
	}
	if m.ShareStun != nil {
		n += 2
	}
	if m.ShareGoodStun != nil {
		n += 2
	}
	if m.NeedStun != nil {
		n += 2
	}
	if m.WantStun != nil {
		n += 2
	}
	if m.WantGoodStun != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StunServer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Domain != nil {
		l = len(*m.Domain)
		n += 1 + l + sovAside(uint64(l))
	}
	if m.Port != nil {
		n += 1 + sovAside(uint64(*m.Port))
	}
	if m.KnownGood != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *StunShare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.StunServers) > 0 {
		for _, e := range m.StunServers {
			l = e.Size()
			n += 1 + l + sovAside(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SDP) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sdp != nil {
		l = len(*m.Sdp)
		n += 1 + l + sovAside(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *GenerationEnded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AnswerTestingEnded) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MoreStun != nil {
		n += 2
	}
	if m.MoreGoodStun != nil {
		n += 2
	}
	if m.Retry != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AcceptRetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MoreStun != nil {
		n += 2
	}
	if m.MoreGoodStun != nil {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Terminate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapExchange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.M != nil {
		n += m.M.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapExchange_Terminate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Terminate != nil {
		l = m.Terminate.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}
func (m *WrapExchange_Sdp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sdp != nil {
		l = m.Sdp.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}
func (m *WrapExchange_Genend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Genend != nil {
		l = m.Genend.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}
func (m *WrapAnswerEnd) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.M != nil {
		n += m.M.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapAnswerEnd_Terminate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Terminate != nil {
		l = m.Terminate.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}
func (m *WrapAnswerEnd_Answerend) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Answerend != nil {
		l = m.Answerend.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}
func (m *WrapRetryAccept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.M != nil {
		n += m.M.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *WrapRetryAccept_Terminate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Terminate != nil {
		l = m.Terminate.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}
func (m *WrapRetryAccept_Retry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Retry != nil {
		l = m.Retry.Size()
		n += 1 + l + sovAside(uint64(l))
	}
	return n
}

func sovAside(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAside(x uint64) (n int) {
	return sovAside(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Hello) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Hello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Hello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v Proto
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAside
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= Proto(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Protos = append(m.Protos, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAside
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAside
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAside
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				if elementCount != 0 && len(m.Protos) == 0 {
					m.Protos = make([]Proto, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v Proto
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAside
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= Proto(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Protos = append(m.Protos, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Protos", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ShareStun = &b
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShareGoodStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.ShareGoodStun = &b
			hasFields[0] |= uint64(0x00000002)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NeedStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.NeedStun = &b
			hasFields[0] |= uint64(0x00000004)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WantStun = &b
			hasFields[0] |= uint64(0x00000008)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WantGoodStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.WantGoodStun = &b
			hasFields[0] |= uint64(0x00000010)
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("shareStun")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("shareGoodStun")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("needStun")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("wantStun")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("wantGoodStun")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StunServer) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StunServer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StunServer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Domain = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Port = &v
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KnownGood", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.KnownGood = &b
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("domain")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("port")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("knownGood")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StunShare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StunShare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StunShare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StunServers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StunServers = append(m.StunServers, &StunServer{})
			if err := m.StunServers[len(m.StunServers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SDP) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SDP: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SDP: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sdp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(dAtA[iNdEx:postIndex])
			m.Sdp = &s
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("sdp")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GenerationEnded) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GenerationEnded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GenerationEnded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnswerTestingEnded) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnswerTestingEnded: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnswerTestingEnded: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MoreStun = &b
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreGoodStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MoreGoodStun = &b
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Retry = &b
			hasFields[0] |= uint64(0x00000004)
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreStun")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreGoodStun")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("retry")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AcceptRetry) Unmarshal(dAtA []byte) error {
	var hasFields [1]uint64
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AcceptRetry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AcceptRetry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MoreStun = &b
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MoreGoodStun", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.MoreGoodStun = &b
			hasFields[0] |= uint64(0x00000002)
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreStun")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("moreGoodStun")
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Terminate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Terminate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Terminate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapExchange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapExchange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapExchange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Terminate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapExchange_Terminate{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sdp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SDP{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapExchange_Sdp{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &GenerationEnded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapExchange_Genend{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapAnswerEnd) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapAnswerEnd: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapAnswerEnd: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Terminate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapAnswerEnd_Terminate{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Answerend", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AnswerTestingEnded{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapAnswerEnd_Answerend{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WrapRetryAccept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAside
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WrapRetryAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WrapRetryAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Terminate{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapRetryAccept_Terminate{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Retry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAside
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAside
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAside
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AcceptRetry{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &WrapRetryAccept_Retry{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAside(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthAside
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAside(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAside
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAside
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAside
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAside
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAside
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAside
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAside        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAside          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAside = fmt.Errorf("proto: unexpected end of group")
)
